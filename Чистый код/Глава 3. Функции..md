1. Компактность функций.
	 Первое правило написание "хороших" функций: функции должны быть компактные. Второе правило "хороших" функций: функции должны быть ещё компактней.
    Функции должны излагать свою историю, и каждая история естественным образом должна подводить читателя к началу следующей истории. 
2. Вложенность функций.
	 Функции не должны содержать вложенных структур, так как это приводит к их увеличению. Это упрощает чтение и понимание функций.
3. Правило одной операции.
> 	 *"Функция должна выполнять только одну операцию. Она должна выполнять её хорошо. И ничего другого делать не должна."*
	 Если функция выполняет только те действия, которые находятся на одном уровне под объявленным именем функции, то эта функция выполняет одну операцию. Функции пишутся прежде всего для разложения более крупной концепции на последовательность действий на следующем уровне абстракции.
	 Чтобы определить, что функция выполняет более одной операции, попробуйте извлечь из неё другую функцию, которая бы не являлась простой переформулировкой реализации.
4.  Секции в функциях.
	 Если вы замечаете, что функцию можно разделить на несколько секций(объявления, инициализация, отбор), то это очевидный признак того, что функция выполняет более одной операции. Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции.
5. Один уровень абстракции на функцию.
	 Смещение уровней абстракции внутри функции всегда создаёт путаницу. Читатель не всегда понимает, является ли некоторое выражение важной концепцией или второстепенной подробностью. Что ещё хуже, при их смешивании функция постепенно начинает обрастать всё большим количеством второстепенных подробностей.
6. Чтение кода сверху вниз: правило понижения.
	 Код должен читаться как рассказ - сверху вниз.
	 За каждой функцией должны следовать функции следующего уровня абстракции. Это позволяет читать код последовательно спускаясь по уровням абстракции в ходе чтения списка функций - это называется "правилом понижения".
7. Используйте содержательные имена.
	 Принцип Уорда:  "Вы работаете с чистым кодом, если каждая функция в основном делает то, что вы от неё ожидали".
	 Не бойтесь использовать длинные имена. Длинное содержательное имя лучше короткого невразумительного.
	 Не бойтесь расходовать время на выбор имени. Опробуйте несколько разных имен и посмотрите, как читается код с каждый из вариантов. Выбор содержательных имен прояснит архитектуру модуля и поможет вам усовершенствовать её. Нередко поиски хороших имен приводят к полезной реструктуризации кода.
8. Аргументы функций.
	 В идеальном случае количество аргументов функций равно нулю(нуль-арная функция). Далее следует использовать функции с одним аргументом (унарные) и с двумя аргументами (бинарные). Функций с тремя аргументами (тернарных) следует по возможности избегать. Необходимость функций с большим количеством (полиарных) аргументов должна быть подкреплена очень вескими доводами - и все равно такие функции лучше не использовать.
	 Аргументы усложняют функции и лишают их значительной части концептуальной мощи.
	 Аргументы создают ещё больше проблем со стороны тестирования.
	 Чем больше входных аргументов, тем более непонятно что по итогу вернёт выходные аргументы функции.
9. Аргументы флаги.
	 Аргументы-флаги уродливы. Она немедленно усложняет сигнатуру метода, громко провозглашая, что функция выполняет больше одной операции.
10. Объекты как аргументы.
	 Если функция должна получать более двух или трёх аргументов, весьма вероятно, что некоторые из этих аргументов стоит упаковать в отдельном датаклассе(Data Class) или  именованном кортеже(Named Tuple).
	 Сокращение количества аргументов посредством создания объектов может показаться жульничеством, но это не так. Если переменные передаются совместно как единое целое, то, скорее всего, вместе они образуют концепцию, заслуживающую собственного имени.
11. Глаголы и ключевые слова.
	 Выбор хорошего имени для функции способен в значительной мере объяснить смысл функции, а также порядок и смысл её аргументов. Например в унарных функциях сама функция и её аргумент должны образовывать естественную пару глагол/существительное. Вызов вида write(name) смотрится весьма информативно. Ещё лучше запись write_field(name) - ещё более информативная, зразу понятно что мы записываем "имя" в "поле" какой-то структуры.
12. Избавьтесь от побочных эффектов.
	 Суть побочных эффектов - ложь. Ваша функция говорит что сделает что-то одно, а по-итогу делает совсем другое, скрытое от пользователя. Такая функция является коварной и вредоносной ложью, которая часто приводит к созданию противоестественных временных привязок и других зависимостей.
13. Выходные аргументы.
	 У читателя не должен появляться вопрос после прочтения сигнатуры: "Что произойдёт с аргументом внутри функции. Что произойдёт с ним на выходи из функции?". Все, что заставляет смотреть внутрь функции для ответа на этот вопрос нарушает естественный ритм чтения кода. Подобных "повторных заходов" следует избегать. Если функция должна изменять чье-то состояние, пусть она изменяет состояние своего объекта-владельца. 
14. Разделение команд и запросов.
	 Функция должна что-то делать или отвечать на какой-то вопрос, но не одновременно. Либо функция изменяет состояние объекта, либо возвращает информацию об этом объекте. Совмещение двух операций часто создаёт путаницу.
15. Используйте исключения вместо возвращения кодов ошибок.
	 Возвращение кодов ошибок функциями-командами является неочевидным нарушением принципа разделения команд и запросов. оно поощряет использование команд в предикатных выражениях if:
	 if delete_all_link(obj) == success:
	 Такие конструкции приводят к созданию структур слишком глубокой вложенности, т. к. при возвращении кода ошибки возникает проблема: вызывающая сторона должна немедленно отреагировать на ошибку.
	 Используйте исключения для изоляции кода выполнения от кода обработки ошибок.
16. Изолируйте блоки try/except.
	 Блоки try/except выглядят весьма уродливо. Они запутывают структуру кода и смешивают обработку ошибок с нормальной обработкой. По этой причине тела try/except рекомендуется выделять в отдельные функции.
17. Обработка ошибок как одна операция.
	 Функции должны выолнять одну операцию. Обработка ошибок - это одна операция. Функция, обрабатывающая ошибки, ничего другого делать не должна.
18. Не повторяйтесь(DRY).
	 Дублирование кода создаёт проблемы, потому что оно увеличивает объем кода, а при изменении алгоритма вам придется вносить изменения сразу в нескольких местах. Так же в несколько раз возрастает вероятность ошибки.
19. Структурное программирование.
	 Соблюдайте правила структурного программирования, изложенные Эдгардом Дейкстрой: каждая функция и каждый блок внутри функции должны иметь одну точку входа и одну точку выхода. Выполнение этого правила означает, что функция должна содержать только одну команду return, в циклах не должны использоваться команды break или continue.
	 Хотя в очень компактных функциях эти правила не приносят особой пользы, только при увеличении объема функций их соблюдение обеспечивает существенных эффект.
	 Но, если ваши функции компактные , то редки вкрапления не принесут вреда, а иногда даже повышают выразительность по сравнению с классической реализацией с одной точкой входа и выхода.
20. Как писать такие функции?
	 Первый вариант может быть неуклюжим и нелогичным, тогда вы переделываете, дополняете и уточняете его, пока он не будет читаться так, как вам хочется.