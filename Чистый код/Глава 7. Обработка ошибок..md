Обработка ошибок необходима, но если они заслоняют собой логику программы - значит, она реализована неверно. 
1. Используйте исключения вместо кодов ошибок.
	 Вызывающая сторона должна проверять ошибки немедленно после вызова. По этой причине при обнаружении ошибки лучше инициализировать исключение. Код вызова становиться более понятным, а его логика не скрывается за кодом обработки ошибок.
2. Начните с написания try/except/else.
	 У исключений есть одна интересная особенность: они определяют область видимости в вашей программе. Размещая код в секции try, вы утверждаете, что выполнение программы может прерваться в любой точке, а затем продолжиться в секции except.
	 Секция except должна остановить программу в целостном состоянии, что бы не произошло в секции try.
	 Определив область видимости при помощи try/except, мы модем использовать методологию TDD для построения остальной необходимой логики.
3. Передавайте контекст с исключениями.
	 Каждое исключение, инициируемое в программе, должно содержать достаточно контекстной информации для определения источника и местонахождения ошибки.
4. Определяйте классы исключений в контексте потребностей вызывающей стороны. 
	 При определении классов исключений в приложениях думать необходимо прежде всего о том, как они будут перехватываться.
	 Создавая обертки для стороннего вызова, вы сокращаете до минимума зависимость от него в своем коде. Обертки так же упрощают имитацию сторонних вызовов в ходе тестирования кода, т.о. вы не ограничиваетесь архитектурными решениями разработчика API.
5. Определите нормальный путь выполнения.
	 Исключение не должно загораживать логику программы. Поэтому можно прятать его за абстракцией более нижнего уровня.
	 Либо воспользоваться паттерном "Особый случай"[Fowler]. Создайте класс или настройте объект так, чтобы он обрабатывал особый случай за него. Это позволит избежать обработки исключительного поведения в клиентском коде. Все необходимое поведение инкапсулируется в объекте особого случая.
6. Не возвращайте None.
	 Возвращая None, мы фактически создаём для себя лишнюю работу, а для вызывающей стороны - лишние проблемы. При этом любой пропущенный в код None - это потенциальная 500-тка.
7. Не передавайте None.
	 Возвращать None из методов плохо, но передавать None при вызове ещё хуже.
	 В большинстве языков программирования не существует хорошего способа справиться со случайной передачей None, ибо придётся тогда в каждой функции/методе прописывать обработку с блоков try/except или assert, поэтому разумно запретить передачу None в списке аргументов по-умолчанию.