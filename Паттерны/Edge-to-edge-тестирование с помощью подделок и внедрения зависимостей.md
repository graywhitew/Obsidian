Когда мы начинаем писать новую систему, то часто фокусируем наше внимание сначала на ключевой логике, управляя ею с помощью прямых юнит-тестов. Но в какой то момент мы хотим протестировать более крупные куски системы вместе.
Для реализации этой идеи мы пишем тесты, которые активизируют всю систему целиком, но подделывать операции ввода-вывода как бы *от края до края*. Преимущество этого подхода в том, что мы должны сделать компоненты с внутренним состоянием явными и передавать их туда-сюда.
Для реализации сущностей, которые будут делать "фейковые" операции используют два подхода monky-patch и реализацию "фейковых" интерфейсов.
Использование подхода monkey-patch для реализации "фейковых" интерфейсов для тестирования принято считать кодом "с душком" по трём причинам:
1. Наложение заплаток на используемые нами зависимости позволяет проводить юнит-тестирование кода, но это никак не улучшает дизайн.
2. Тесты с использованием заплаток тяготеют к большей связанности с деталями реализации кодовой базы. Такая связанность между кодом и тестом, как правило, делает тесты ненадежными.
3. Чрезмерное использование имитаций приводит к сложным тестам, которые не способны объяснить код.
Вот краткое и несколько упрощенное определение разницы между имитациями и подделками:
	- Имитация (mocks), или подставные объекты, используются для проверки того, каким образом что-то используется. Они связаны с лондонской школой TDD.
	- Подделики(fakes) - это рабочие реализации того, что они заменяют. Подделки предназначены для использования только в тестах. Они не будут работать "в реальной жизни", но вы сможете использовать их, чтобы делать утверждения о конечном состоянии системы, а не о поведении в процессе, поэтому они связаны с классическим стилем TDD.
Если тесты слишком перегружаются установочным кодом из-за большого количества имитаций, мы не видим интересующую нас информацию.