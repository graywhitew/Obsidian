Паттерн "Репозиторий" упрощает абстракцию хранения данных, которая позволяет устранить связанность слоя модели и слоя данных. 
![[Pasted image 20241123160648.png]]
Использование данного паттерна позволяет извлекать информацию о сущностей из БД и создавать из неё экземпляры объектов модели предметной области, и так же позволяет сохранять их обратно в БД.
В web-фремворках используется структура "модель-вид-шаблон"(Model-View-Template), как и "модель-вид-контроллер"(Model-View-Controller). Их цель состоит в том, чтобы держать слои разделенными и чтобы каждый слой зависел только от расположенного ниже.
![[Pasted image 20241123161317.png]]
Цель использования данного паттерна состоит в том, чтобы избавится от зависимостей, т.к. не хотим, чтобы инфраструктурные обязанности растекались по модели предметной области и замедляли юнит-тесты или внесение изменений.
Вместо этого стремимся реализовать то, что модель находится "внутри" и зависимости втекают в неё; это то, что иногда называют *луковой архитектурой*.
![[Pasted image 20241123161615.png]]
Благодаря тому, что мы будем использовать объектно-реляционное отображение(ORM) это позволит нам иметь неосведомленность об используемой системе постоянного хранения, что позволит держать модель независимой от конкретных технологий баз данных.
![[Pasted image 20241123162351.png]]
Но это не единственный способ использовать SQLAlchemy. Альтернативой является отдельное определение схемы и определение явного попарного отображения, задачей которого будет конвертирование между схемой и моделью предметной области. В SQLAlchemy это называется *классических попарным отображением*.
![[Pasted image 20241123162711.png]]
В данном случае Объектно-реляционное отображение импортирует (или "зависит от" или "осведомлено о") модель предметной области, а не наоборот. Это позволяет определить таблицы и столбцы базы данных с помощью абстракций SQLAlchmy, а использование функции mapper позволяет привязать классы модели предметной области к различным таблицам, которые мы определили.
В итоге, если мы вызовем start_mappers, то сможем легко загружать и сохранять экземпляры модели предметной области из базы данных и в базу данных. Но если функция не будет вызвана, то классы модели предметной области остаются в блаженном неведении о базе данных.
Это позволяет получить все преимущества SQLAlchemy, включая возможность делать миграции и делать запросы прозрачно с помощью классов предметной области.
Благодаря этому мы можем достигнуть инверсии традиционной зависимости - модель предметной области остаётся "чистой" и свободной от инфраструктурных обязанностей. Это позволяет нам отказаться от SQLAlchemy и использовать любое другое ORM или другую систему постоянного хранения данных, и предметная область не нуждается в изменении.

Паттерн "Репозиторий" - это абстракция поверх системы постоянного хранения. Он скрывает скучные детали доступа к данным, делая вид, что все данные находятся прямо в памяти.
Простейший репозиторий имеет всего два метода: add(), чтобы поместить новый элемент в репозиторий, и get(), чтобы вернуть ранее добавленный элемент. Придерживаемся использования этих методов для доступа к данным модели и в слое служб предметной области. Это условие не позволяет нам прицепить модель предметной области к базе данных.
Вот как будет выглядеть абстрактный базовый класс для репозитория.
![[Pasted image 20241123210700.png]]
Паттерн "Репозиторий" позволит легко вносить фундаментальные изменения в способ хранения, его так же легко подделать под юнит-тесты.
![[Pasted image 20241123211032.png]]
Так же появляется возможность реализации поддельного репозитория для тестов.
![[Pasted image 20241123212008.png]]
![[Pasted image 20241123212037.png]]
![[Pasted image 20241123214719.png]]
![[Pasted image 20241123214832.png]]